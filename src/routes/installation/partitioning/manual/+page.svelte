<script>
	import { getRead, getBlueprint } from '/src/routes/installation/global.js';
	import { invoke } from '@tauri-apps/api/core';
	import List from '$lib/components/partitions/List.svelte';
	import Detail from '$lib/components/partitions/Detail.svelte';
	import Preview from '$lib/components/partitions/Preview.svelte';
	import Navigation from '$lib/components/Navigation.svelte';
	import GlowingText from '$lib/components/ui/GlowingText.svelte';
	import { showModal } from '$lib/stores/modalStore.js';

	let selectedDisk = $state(0);
	let selectedPartition = $state(0);

	let showEdit = $state(false);
	let newPartition = $state(false);

	let diskSize = $state(0);
	let diskPath = $state('');

	let highestNumber = $state(null);

	let firmwareType = $state('');

	let originalPartition = $state([]);
	let modifiedPartition = $state([]);
	let tempModifiedPartition = $state([]);

    let disableNext = $state(true);

	let newPartitionIndex = $state(0);
	let warningMessage = $state(
		'This action will remove all of your data. Please backup your data before proceeding.'
	);

	let bootPartitionIndex = $state(null);

	let storage = $state({
		diskPath: null,
		partitionTable: 'gpt',
		newPartitionTable: false,
		layoutChanged: false,
		autogenerated: false,
		autogeneratedMode: '',
		installMethod: 'manual',
		partitions: null
	});

	const getBootPartitionIndex = () => {
		let result = -1;

        if (selectedDisk.partitions) {
            if (firmwareType === 'UEFI') {
                result = selectedDisk.partitions.findIndex((p) => p.flags?.includes('esp') ?? false);
            } else {
                result = selectedDisk.partitions.findIndex((p) => p.flags?.includes('bios_grub') ?? false);
            }
        } 

		bootPartitionIndex = result === -1 ? null : result;
	};

	const setup = async () => {
		let read = await getRead();
		let blueprint = await getBlueprint();

		firmwareType = read.firmware;

		let selectedDiskPath = blueprint.storage.diskPath || null;
		let disk = read.disk?.find((disk) => disk.diskPath === selectedDiskPath) ?? null;

		selectedDisk = disk || null;

		getBootPartitionIndex();

		let newPartitions = [];

		storage.diskPath = selectedDiskPath;
		storage.partitions = selectedDisk.partitions || null;
		storage.partitionTable = selectedDisk.label ? selectedDisk.label : 'gpt';
        storage.newPartitionTable = selectedDisk.label ? false : true;

		let partitions = selectedDisk.partitions;
		diskSize = Number(selectedDisk.size.slice(0, -1));
		diskPath = selectedDisk.diskPath;

        if (partitions) {
            for (let i of partitions.keys()) {
                let p = {
                    number: Number(partitions[i].number),
                    diskPath,
                    path: partitions[i].partitionPath,
                    size: Number(partitions[i].size.slice(0, -1)),
                    start: Number(partitions[i].start.slice(0, -1)),
                    end: Number(partitions[i].end.slice(0, -1)),
                    filesystem: partitions[i].filesystem?.includes('swap') ? 'swap' : partitions[i].filesystem,
                    label: null,
                    format: false,
                    mountpoint: null,
                    label: partitions[i].name,
                    flags: partitions[i].flags ? partitions[i].flags : [],
                    schemas: selectedDisk.label.toLowerCase() === 'gpt' ? 'gpt' : 'mbr'
                };

                newPartitions.push(p);
            }
        } else {
            newPartitions.push({
                number: 0,
                diskPath,
                path: null,
                size: Number(disk.size.slice(0, -1)),
                start: 2048,
                end: Number(disk.size.slice(0, -1)) - 1,
                filesystem: null,
                label: null,
                format: false,
                mountpoint: null,
                flags: []
            })
        }

		modifiedPartition = tempModifiedPartition = originalPartition = newPartitions;
		highestNumber = Math.max(...modifiedPartition.map((p) => p.number)) || 0;
	};

	const revertChanges = () => {
		modifiedPartition = JSON.parse(JSON.stringify(originalPartition));
		tempModifiedPartition = JSON.parse(JSON.stringify(originalPartition));
		getBootPartitionIndex();
	};

	const cancelNewPartitionTable = () =>{
		showModal({
			isOpen: true
		})
	}

	const showNewPartitionTableWarning = () => {
		showModal({
			isOpen: false,
			type: 'error',
			title: 'Partition Error !',
			content: warningMessage,
			confirmText: 'OK',
			cancelText: 'Cancel',
			showCancel: true,
			onConfirm: () => newPartitionTable(),
			onCancel: () => cancelNewPartitionTable()
		});
	};

	const newPartitionTable = () => {
		showEdit = false;
		storage.newPartitionTable = true;

		let partition = {
			number: 1,
			diskPath,
			path: null,
			size: diskSize,
			start: 2048,
			end: diskSize - 1,
			filesystem: null,
			format: false,
			mountpoint: null,
			label: null,
			flags: []
		};

		selectedPartition = 0;
		highestNumber = 0;
		bootPartitionIndex = null;
		modifiedPartition = [partition];
		tempModifiedPartition = [partition];
	};

	const handleSetStorage = async () => {

        let partitionWithRoot = modifiedPartition.find((p) => p.mountpoint?.includes('/') ?? false);

        let filteredPartition = modifiedPartition.map((p) => {
            return p.path ? (p.path.includes('#') ? { ...p, path: null } : p) : p;
        });

        storage.partitions = filteredPartition;

        if (storage.partitionTable === "gpt") {

            if (firmwareType === "UEFI") {
                
                let partitionWithBoot = filteredPartition.find((p) => p.mountpoint?.includes('boot') ?? false);

                if (partitionWithBoot && partitionWithRoot) {
                    let bootloaderPath = partitionWithBoot.path;
                    let bootloader = {
                        firmwareType,
                        path: bootloaderPath
                    };

                    await invoke('blueprint_set_bootloader', { bootloader: JSON.stringify(bootloader) });
                    await invoke('blueprint_set_storage', { storage: JSON.stringify(storage) });
                } else {
                    alert('Root or EFI partition does not exist');
                }
            } else {
                
                let partitionWithBiosGrubFlags = filteredPartition.find((p) => p?.flags?.includes('bios_grub') ?? false);

                if (partitionWithBiosGrubFlags && partitionWithRoot) {
                    let bootloaderPath = partitionWithBiosGrubFlags.path;
                    let bootloader = {
                        firmwareType,
                        path: bootloaderPath
                    };

                    await invoke('blueprint_set_bootloader', { bootloader: JSON.stringify(bootloader) });
                    await invoke('blueprint_set_storage', { storage: JSON.stringify(storage) });
                } else {
                    alert('Root or bootloader partition does not exist');
                }
            }
            
        } else {
            
            if (partitionWithRoot) {

                let bootloaderPath = partitionWithRoot.path;
                let bootloader = {
                    firmwareType,
                    path: bootloaderPath
                };

                await invoke('blueprint_set_bootloader', { bootloader: JSON.stringify(bootloader) });
                await invoke('blueprint_set_storage', { storage: JSON.stringify(storage) });
            } else {
                alert('Root partition does not exist');
            }
        }
	};

    // Next button state
    $effect(() => {
        let rootExist = modifiedPartition.find(p => p.mountpoint == "/");
        let rootSufficient = rootExist?.size >= 41938944 ?? false;

        if (storage.partitionTable === "gpt" && firmwareType === "UEFI") {

            let espExist = modifiedPartition.find(p => p.mountpoint == "/boot/efi");
            disableNext = !(espExist && rootExist && rootSufficient);

        } else if (storage.partitionTable === "gpt" && firmwareType === "BIOS") {

            let mbrExist = modifiedPartition.find(p => p.flags?.includes("bios_grub") ?? false);
            disableNext = !(rootExist && mbrExist && rootSufficient);

        } else {
            disableNext = !rootExist;
        }
    })

    // Unallocated partition alignment
	$effect(() => {
		for (let i = 0; i < modifiedPartition.length - 1; i += 1) {
			let current = modifiedPartition[i];
			let next = modifiedPartition[i + 1];

			if (!current.path && !next.path) {
				current.size += next.size;
				current.end = current.start + current.size - 1;

				modifiedPartition.splice(i + 1, 1);
				modifiedPartition = modifiedPartition.map((p) =>
					p.number > i + 1 ? { ...p, number: p.number - 1 } : p
				);

				selectedPartition = i;
			}
		}
	});
</script>

{#await setup() then}
	<div class="flex flex-col p-5 gap-y-2">
		<div class="flex justify-between">
			<div class="flex-1 min-w-[300px]">
				<GlowingText size="[28px]" text="Manual Partitions" />
			</div>
			<div class="flex w-[350px] gap-2.5">
				<button
					onclick={showNewPartitionTableWarning}
					class="flex w-full h-[40px] justify-center items-center gap-[7.963px] rounded-[14px] border-[0.239px] border-[#3C6350] bg-[#101010] hover:shadow-[0_0_7.167px_rgba(38,167,104,0.8)] active:shadow-[0_0_7.167px_rgba(38,167,104,0.8)] transition-all duration-200"
				>
					<img src="/plus.svg" alt="icon" />
					<span
						class="text-[#4CDA95] font-['Plus_Jakarta_Sans'] text-[13px] font-bold leading-[140%]"
					>
						New Partition Table
					</span>
				</button>

				<button
					onclick={revertChanges}
					class="flex w-full h-[40px] justify-center items-center gap-[7.963px] rounded-[14px] border-[0.239px] border-[#3C6350] bg-[#101010] hover:shadow-[0_0_7.167px_rgba(38,167,104,0.8)] active:shadow-[0_0_7.167px_rgba(38,167,104,0.8)] transition-all duration-200"
				>
					<img src="/revert.svg" alt="icon" />
					<span
						class="text-[#4CDA95] font-['Plus_Jakarta_Sans'] text-[13px] font-bold leading-[140%]"
					>
						Revert Changes
					</span>
				</button>
			</div>
		</div>

		<div class="">
			<Preview bind:modifiedPartition bind:diskSize />
		</div>

		<div class="flex flex-row flex-auto space-x-2 text-white">
			<List
				bind:selectedPartition
				bind:modifiedPartition
				bind:showEdit
				bind:newPartition
				bind:highestNumber
				bind:bootPartitionIndex
			/>

			{#key [modifiedPartition, selectedPartition, showEdit]}
				{#if tempModifiedPartition[selectedPartition]}
					<Detail
						readOnly={!showEdit}
						bind:showEdit
						bind:tempModifiedPartition
						bind:modifiedPartition
						bind:selectedPartition
						bind:newPartition
						bind:newPartitionIndex
						bind:bootPartitionIndex
						bind:highestNumber
						bind:partitionTable={storage.partitionTable}
						{firmwareType}
					/>
				{/if}
			{/key}
		</div>
	</div>
{/await}

<Navigation
	currentStep={4}
	currentTitle="Manual Partitioning"
	prevPath="/installation/partitioning"
	nextPath="/installation/account"
	nextAction={handleSetStorage}
    { disableNext }
/>
